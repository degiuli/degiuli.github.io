<?xml version="1.0"?>
<content collectionGUID="FB58F55C-9585-4C68-BAD6-2F593DC4614A">
  <lastEdited clientType="local-build-20130324" date="2013-03-24 21:04:12 +0000"/>
  <textBox id="generic-header-attribute" dynamic="no" visible="yes">
    <richText>&lt;a href="perma://BLPageReference/2D085D6A-902D-4579-899A-CF8E11275EFB"&gt;Windows Debugging Series&lt;/a&gt;</richText>
  </textBox>
  <textBox id="generic-title-attributes" dynamic="no" visible="yes">
    <richText>Stack Corruption</richText>
  </textBox>
  <textBox id="generic-datefield-attributes" dynamic="no" visible="yes">
    <richText>24 de fevereiro de 2013</richText>
  </textBox>
  <textBox id="generic-body-attributes" dynamic="no" visible="yes">
    <richText>&lt;i&gt;What is a Stack?&lt;/i&gt;&#xD;&#xD;Stack is one of the most common data structure. It is pretty simple data structure that can be equated to a stack of plates or papers, where you push a new on top of it and pop from the top of it. The top is the next to be pushed or popped. In computers, the stack is in fact the lower addresses. One very good clarification about stack is the &lt;a href="http://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/"&gt;Where the top of the stack is on x86&lt;/a&gt; post from Eli Bendersky&#x2019;s blog.&#xD;&#xD;In Windows system, stack is just a block of memory assigned by the operating system to a running thread. The stack is also used to track the function calls chain, including allocation of local variables and parameter passing. Once a function is called, a new frame is created on the stack and it will grows bigger and bigger as more and more functions are called. The way a function call grows in the stack depends on the CPU architecture (x86, ARM, RISC, PowerPC). The x86, which will be the focus of our discussion, has some calling conventions that directly affect how the data is placed on the stack. &#xD;&#xD;&lt;i&gt;x86 Calling Convention&lt;/i&gt;&#xD;&#xD;Now, let&#x2019;s look at the x86 architecture calling convention. This information may be important to understand what a dump file can show. This will also describe the how a stack is filled and the function decoration (how the compiler and linker builds the name of a function). Also, calling conventions is nothing more than a contract between the caller and callee functions. It specifies rules that both must agree.&#xD;&#xD;The most important types of calling conventions are:&#xD;&#xD;&lt;i&gt;cdecl&lt;/i&gt;&#xD;cdecl, or C declaration, originates from the C language and is defined at __cdecl. Caller function should clear the stack. Parameters will be passed by via stack from right (on the top) to left (on the bottom). Also, the function will be prefixed by &#x2018;_&#x2019;.&#xD;&#xD;Let&#x2019;s look at the sample below:&#xD;int __cdecl callee(int, int, int);&#xD;&#xD;int __cdecl caller(void)&#xD;{&#xD;	int ret;&#xD;	&#xD;	ret = callee(1,2,3);&#xD;	ret += 5;&#xD;	return ret;&#xD;}&#xD;&#xD;Using the assembly code, the caller will firstly, push the 3 to stack, then 2 and finally 1 before call the callee function:&#xD;push    $3&#xD;push    $2&#xD;push    $1&#xD;call	    _callee&#xD;&#xD;There are also few details about the registers that should be manipulated in that operation, which also depends on the type of the parameter. There are a vast number of sources that you can look for more details about this information.&#xD;&#xD;&lt;i&gt;stdcall&lt;/i&gt;&#xD;stdcall is basically used by Win32, with exceptions for variadic functions, and is defined as __stdcall. Similar to the cdecl, it uses the stack to pass parameter, also from left to right, but it is no longer reponsible for cleaning up the stack; the called function should clear stack. Function name are decorated with &#x2018;_&#x2019; appended by &#x2018;@&#x2019; followed by the number of bytes of stack space required.&#xD;Back to the callee sample above:&#xD;int __stdcall callee(int, int, int);&#xD;it decorated name would be: _callee@12, because each int parameter has 4 bytes.&#xD;&#xD;&lt;i&gt;fastcall&#xD;&lt;/i&gt;fastcall, defined as __fastcall, is quite similar to the stdcall, except that the first two parameters is passed on ECX and EDX registers and the other are passed by stack. The called function is responsible to clear the stack and its decoration is exactly the same as stdcall.&#xD;&#xD;&lt;i&gt;thiscall&lt;/i&gt;&#xD;This is default convention for for C++ member functions that do not use variable arguments. The first parameter, which is the &#x2018;this&#x2019; parameter, is passed in ECX register, with the remainder passed on the stack as in stdcall. As stdcall, the called function is responsible to clear the stack. The function names are decorated by the C++ compiler in an extremely complicated mechanism that encodes the type of each parameter, among other things. This is necessary because C++ permits function overloading, so a complex decoration scheme must be used so that the various overloads have different decorated names. One interesting post about the C++ decorate names is &lt;a href="http://mearie.org/documents/mscmangle/"&gt;Microsoft C++ Name Mangling Scheme&lt;/a&gt;. There are more details in &lt;a href="http://msdn.microsoft.com/en-us/library/56h2zst2.aspx"&gt;MSDN&lt;/a&gt;.&#xD;&#xD;&lt;i&gt;Calling Conventions Mismatch&lt;/i&gt;&#xD;&#xD;Now that stack is no longer an obscure thing in software processing, let&#x2019;s start looking some stack issues. The first is the calling conventions mismatch. As introduced earlier, the different types of calling conventions lead to different way the stack is manipulated. Both caller and callee functions must agree with the rules. Let&#x2019;s suppose there is DLL with one function:&#xD;void __stdcall DllProc(int);&#xD;that prints the argument and we also have an application that dynamically loads the DLL and executes the function:&#xD;typedef int (__cdecl *DLLPROC)(int);&#xD;&#xD;void CallProc(DLLPROC pProc,int arg)&#xD;{&#xD;    pProc(arg);&#xD;}&#xD;&#xD;int __cdecl main(int argc,char *argv[])&#xD;{&#xD;    HMODULE hMod = LoadLibrary("DLL.dll");&#xD;    if(mod)&#xD;    {&#xD;        DLLPROC pProc = (DLLPROC)GetProcAddress(hMod,"DllProc");&#xD;        if(pProc)&#xD;        {&#xD;            CallProc(pProc,argc);&#xD;        }&#xD;        FreeLibrary(hMod);&#xD;    }&#xD;}&#xD;&#xD;The code is can be compiled and linked. Running the application may not cause any issue and there will be an output but would not be the expected one simply because the calling conventions. The main function will not expect the DLL!DllProc to cleanup the stack, but it will as defined as __stdcall. Before the DLL!DllProc returns, it is responsible to cleanup the stack, which means it will modify the registers accordingly. However, the main function will also perform the same operation because it believes the DLL!DllProc will not do it due to the fact the function pointer is set as __cdecl.&#xD;&#xD;This modifies the stack and causes unpredictable issues. In this specific case, it may probably run the DLL!DllProc again. If this example is run under a debugger, this will show an exception.&#xD;&#xD;&lt;i&gt;Stack Overrun&lt;/i&gt;&#xD;&#xD;Stack overrun, also know as buffer overflow or stack buffer overflow, occurs when a thread indiscriminately overwrites portions of its call stack reserved for other purpose. Examples of this issue are overwriting the return address for a particular frame, overwriting entire frame, exhausting the stack completely. The effects of stack overrun range from crash, unpredictable behavior and even critical security holes.&#xD;&#xD;One common mistake that causes this issue is copying a string to a smaller area. Take the following sample code below:&#xD;void foo(char *pdata)&#xD;{&#xD;    char data[10] = {0};    //stack memory&#xD;    strcpy(data,pdata);&#xD;    std::cout &lt;&lt; data &lt;&lt; std::endl;&#xD;}&#xD;&#xD;int main(int argc, char *argv[])&#xD;{&#xD;    if(argc&gt;1)&#xD;    {&#xD;        //pass first argument to function&#xD;        foo(argv[1]);&#xD;    }&#xD;    return 0;&#xD;}&#xD;What would happen if the argv[1] string is bigger than 10 bytes? A crash would occur because the characters beyond the 10th position, characters out of the allocated memory boundaries, would write the stack memory changing its contents, causing this memory to be invalid. If this memory is, for instance, an instruction address, it can certainly redirect the application execution to wrong path. So, the consequence is a security hole. A hacker can inject a piece of code to gain access to the system by using this technic.&#xD;&#xD;&lt;i&gt;Stack Overflow&lt;/i&gt;&#xD;&#xD;Stack overflow usually occurs when too much memory is used on stack, which contains a limited amount of memory. The memory size available on stack depends on the language used, the machine architecture, multi-threading, and the amount memory available. When an application attempts to allocate more stack memory that available, it typically crashes as a result of the overflow. The two main reason that results in stack overflow are:&#xD;very or infinite recursion:&#xD;int foo();&#xD;{&#xD;    return foo();&#xD;}&#xD;very large stack variable:&#xD;int foo();&#xD;{&#xD;    double very_large_array[1000000];&#xD;    //do something ...&#xD;    return something...;&#xD;}&#xD;There are two basic rules to avoid this issue: (1) be care when doing recursion, always verifying completely the out case there is no infinite recursion or it is called so many times; (2) do not use much stack variable by allocating any variable greater than 256 bytes.&#xD;&#xD;&lt;i&gt;Stack Underrun&lt;/i&gt;&#xD;&#xD;Stack underrun errors as less common, but it can occurs when the stack to be read becomes empty.</richText>
  </textBox>
</content>
