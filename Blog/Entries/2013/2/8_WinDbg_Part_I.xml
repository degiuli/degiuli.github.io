<?xml version="1.0"?>
<content collectionGUID="FB58F55C-9585-4C68-BAD6-2F593DC4614A">
  <lastEdited clientType="local-build-20130324" date="2013-03-24 21:04:13 +0000"/>
  <textBox id="generic-header-attribute" dynamic="no" visible="yes">
    <richText>&lt;a href="perma://BLPageReference/2D085D6A-902D-4579-899A-CF8E11275EFB"&gt;windows debugging series&lt;/a&gt;</richText>
  </textBox>
  <textBox id="generic-title-attributes" dynamic="no" visible="yes">
    <richText>WinDbg Part I</richText>
  </textBox>
  <textBox id="generic-datefield-attributes" dynamic="no" visible="yes">
    <richText>8 de fevereiro de 2013</richText>
  </textBox>
  <textBox id="generic-body-attributes" dynamic="no" visible="yes">
    <richText>As part of the Debugging Tools for Windows, WinDbg is a very known debugging tool that can use for both live and postmortem debug, user and kernel mode with a graphical user interface.&#xD;&#xD;The focus of this command will be the !analyze extension command. Its goals is to automatic analyze failures, detecting and assigning to known problems of dumps. Its parameters are:&#xD;!analyze -v or !analyze -v -hang. The former is used for crash dumps and latter for hanging dumps.&#xD;&#xD;Both commands bring a list of information that help us to track the problem. The details description of the command output is discussed in following list:&#xD;&#xD;&lt;i&gt;FAULTING_IP&lt;/i&gt;: shows the value of the instructions pointer when the fault occurred:&#xD;FAULTING_IP: &#xD;kernel32!RaiseException+53&#xD;7c812afb 5e              pop     esi&#xD;&#xD;&lt;i&gt;EXCEPTION_RECORD:&lt;/i&gt; gives more detail about the exception that occurred in the form of an exception record:&#xD;EXCEPTION_RECORD:  1e77e998 -- (.exr 0x1e77e998)&#xD;.exr 0x1e77e998&#xD;ExceptionAddress: 7c812afb (kernel32!RaiseException+0x00000053)&#xD;   ExceptionCode: e0434352 (CLR exception)&#xD;  ExceptionFlags: 00000001&#xD;NumberParameters: 5&#xD;   Parameter[0]: 80131500&#xD;   Parameter[1]: 00000000&#xD;   Parameter[2]: 00000000&#xD;   Parameter[3]: 00000000&#xD;   Parameter[4]: 79140000&#xD;ExceptionAddress shows the address where the exception occurred; ExceptionCode tells us the exact exception that caused the fault; ExceptionFlag show the flag associated with the exception; NumberParameters tells us the number of parameters associated with exception.&#xD;&#xD;&lt;i&gt;FAULTING_THREAD:&lt;/i&gt; tells us which thread caused the fault to occur:&#xD;FAULTING_THREAD:  ffffffff&#xD;In this specific case, the thread id was not saved, but it is possible to determine which thread caused the fault using other command that will be discussed in later posts.&#xD;&#xD;&lt;i&gt;BUGCHECK_STR:&lt;/i&gt; represents a textual description of the &#x2018;bugcheck&#x2019; that occurred:&#xD;BUGCHECK_STR:  APPLICATION_FAULT_CLR_EXCEPTION_WRONG_SYMBOLS&#xD;&#xD;&lt;i&gt;PROCESS_NAME:&lt;/i&gt; tells us the name of the process that exhibiting the fault:&#xD;PROCESS_NAME:  devenv.exe&#xD;&#xD;&lt;i&gt;ERROR_CODE:&lt;/i&gt; tells us the error code (NTSTATUS) that caused the fault:&#xD;ERROR_CODE: (NTSTATUS) 0xe0434f4d - &lt;Unable to get error code text&gt;&lt;i&gt;&#xD;&lt;/i&gt;Unfortunately, there is no text information, but in most of cases, there is the information. In lost of cases the text information is not provided, it is possible to identify it by analyzing the content of the id. In this specific case it is possible to infer the code is an E0 &#x2018;COM&#x2019; (43 = &#x2018;C&#x2019;, 4f = &#x2018;O&#x201D;, 4d = &#x2018;M&#x2019;).&#xD;Other details can be obtained from Windows EXCEPTION_RECODE structure in &lt;a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363082%28v%3Dvs.85%29.aspx"&gt;MSDN&lt;/a&gt;.&lt;i&gt;&#xD;&#xD;DEFAULT_BUCKED_ID:&lt;/i&gt; details the general category of fault that this particular fault falls under:&#xD;DEFAULT_BUCKET_ID:  CLR_EXCEPTION&#xD;&#xD;&lt;i&gt;PRIMARY_PROBLEM_CLASS:&lt;/i&gt; indicates the primary class of the problems that the fault was categorized in:&#xD;PRIMARY_PROBLEM_CLASS:  CLR_EXCEPTION&#xD;&#xD;&lt;i&gt;LAST_CONTROL_TRANSFER:&lt;/i&gt; shows the last two functions calls made on the stack:&#xD;LAST_CONTROL_TRANSFER:  from 7928bd60 to 7c812afb&#xD;The ln &lt;address&gt; command shows the name of the function associated with the address. In this sample, the control was transferred from kernel32!RaiseException to clr!RaiseTheExceptionInternalOnly. This information can also be taken from the stack trace.&#xD;&#xD;&lt;i&gt;STACK_TEXT:&lt;/i&gt; shows the stack trace of the thread:&#xD;STACK_TEXT:  &#xD;7c812afb kernel32!RaiseException+0x53&#xD;7928bd60 clr!RaiseTheExceptionInternalOnly+0x276&#xD;7928bf99 clr!IL_Throw+0x14c&#xD;0f840c32 Microsoft_Build_ni+0x380c32&#xD;0f5b88eb Microsoft_Build_ni+0xf88eb&#xD;0f5b8718 Microsoft_Build_ni+0xf8718&#xD;79b2ae5b mscorlib_ni+0x2aae5b&#xD;79ab7ff4 mscorlib_ni+0x237ff4&#xD;79ab7f34 mscorlib_ni+0x237f34&#xD;79b2ade8 mscorlib_ni+0x2aade8&#xD;791421bb clr!CallDescrWorker+0x33&#xD;79164be2 clr!CallDescrWorkerWithHandler+0x8e&#xD;79164d84 clr!MethodDesc::CallDescr+0x194&#xD;79164db9 clr!MethodDesc::CallTargetWorker+0x21&#xD;79294073 clr!ThreadNative::KickOffThread_Worker+0x1e1&#xD;792f0d78 clr!Thread::DoExtraWorkForFinalizer+0x114&#xD;792f0dfa clr!Thread::ShouldChangeAbortToUnload+0x101&#xD;792f0eb5 clr!Thread::ShouldChangeAbortToUnload+0x399&#xD;792f0f51 clr!Thread::ShouldChangeAbortToUnload+0x43a&#xD;79293f46 clr!ManagedThreadBase::KickOff+0x15&#xD;79293e41 clr!ThreadNative::KickOffThread+0x23e&#xD;792ec060 clr!Thread::intermediateThreadProc+0x4b&#xD;7c80b729 kernel32!BaseThreadStart+0x37&#xD;&#xD;&lt;i&gt;FOLLOWUP_IP:&lt;/i&gt; shows the instruction that most likely caused the fault:&#xD;FOLLOWUP_IP: &#xD;clr!RaiseTheExceptionInternalOnly+276&#xD;7928bd60 c745fcfeffffff  mov     dword ptr [ebp-4],0FFFFFFFEh&#xD;&#xD;One very important note regarding this and the STACK_TEXT fields is: DO NOT ALWAYS BELIEVE ON THEM! The dump my show them as the caused of the fault, but, as discussed in corruption posts, unpredictable behavior may have led to this point, when the real root of the fault is far away behind! This shall be discussed in other posts.&#xD;&#xD;&lt;i&gt;SYMBOL_STACK_INDEX:&lt;/i&gt; corresponds to the frame in the thread&#x2019;s stack trace that caused the fault:&#xD;SYMBOL_STACK_INDEX:  1&#xD;&#xD;&lt;i&gt;FOLLOWUP_NAME and FOLLOWUP:&lt;/i&gt; show who should be following up with this particular fault:&#xD;FOLLOWUP_NAME:  MachineOwner&#xD;By default, MachineOwner is used but this can be changed modifying the triage.ini file, located at the triage folder in the debugger installation path. You can either ignore a module, or part of it, or associated one module, or part of it, to a specified triage group or person. See the samples below:&#xD;nt!Zw*=ignore&#xD;This means the any fault on Zw* function of NT module will be ignored.&#xD;AppSample!*=Support Team (SupportTeam@AppSampleCompany.com)&#xD;This means that any fault on AppSample module the FOLLOWUP_NAME field will be filled with Support Team information.&#xD;&#xD;&lt;i&gt;MODULE_NAME:&lt;/i&gt; states the module that is exhibiting the fault:&#xD;MODULE_NAME: clr&#xD;&#xD;&lt;i&gt;IMAGE_NAME:&lt;/i&gt; states the name of the image that fault occurred:&#xD;IMAGE_NAME:  clr.dll&#xD;&#xD;&lt;i&gt;DEBUG_FLR_IMAGE_TIMESTAMP:&lt;/i&gt; shows the image time stamp where the fault occurred:&#xD;DEBUG_FLR_IMAGE_TIMESTAMP:  4e181a6d&#xD;&#xD;&lt;i&gt;SYMBOL_NAME:&lt;/i&gt; shows the symbolic name where the fault occurred:&#xD;SYMBOL_NAME:  clr!RaiseTheExceptionInternalOnly+276&#xD;&#xD;&lt;i&gt;STACK_COMMAND:&lt;/i&gt; shows the command that were executed to get the stack trace for the faulting thread:&#xD;STACK_COMMAND:  .cxr 1E77E9C0 ; kb ; dds 1e77ec8c ; kb&#xD;This field helps to understand the steps performed by the !analyze extension command. More details about the command performed above and others will be discussed in laters posts.&#xD;&#xD;&lt;i&gt;FAILURE_BUCKET_ID and BUCKET_ID:&lt;/i&gt; show the specific category of the problems that the fault falls under:&#xD;FAILURE_BUCKET_ID:  CLR_EXCEPTION_e0434f4d_clr.dll!RaiseTheExceptionInternalOnly&#xD;BUCKET_ID:  APPLICATION_FAULT_CLR_EXCEPTION_WRONG_SYMBOLS_clr!RaiseTheExceptionInternalOnly+276&#xD;This information can be used by the !analyze extension command to determine what additional information to display in the analysis result.&#xD;&#xD;&lt;i&gt;CONTEXT:&lt;/i&gt; shows the fault context address and registers at the moment of the fault occurred:&#xD;CONTEXT:  1e77e9c0 -- (.cxr 0x1e77e9c0)&#xD;.cxr 0x1e77e9c0&#xD;eax=1e77ec90 ebx=00000005 ecx=00000000 edx=0000004b esi=1e77ed50 edi=161a9158&#xD;eip=7c812afb esp=1e77ec8c ebp=1e77ece0 iopl=0         nv up ei pl nz na pe nc&#xD;cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206&#xD;kernel32!RaiseException+0x53:&#xD;7c812afb 5e              pop     esi&#xD;.cxr&#xD;Resetting default scope&#xD;The 1e77e9c0 address is the context of the fault. This field also shows the same information provided by the FAULTING_IP field.&#xD;&#xD;The order the data is exhibited depends on the type of the fault. Furthermore, there may be other details depending on the fault. For instance, in case of a hang (!analyze -v -hang), one may see the following details:&#xD;&#xD;&lt;i&gt;CRITICAL_SECTION:&lt;/i&gt; shows the address of the critical section tha was found and analyzed in the starting thread.&#xD;&#xD;&lt;i&gt;BLOCKING_THREAD:&lt;/i&gt; gives the ID of the thread that is blocking on the critical section shown in CRITICAL_SECTION field.&#xD;&#xD;&lt;i&gt;DERIVED_WAIT_THREAD:&lt;/i&gt; is at the heart of the hang analysis capabilities of the !analyze extension command. When the command runs, it attempts to derive how the wait chain looks for each of the threads in the process associated with the critical section listed in the CRITICAL_SECTION field. It tries to retrieve which thread is waiting for the critical section and which thread owns it.&#xD;&lt;i&gt;&#xD;WAIT_CHAIN_COMMAND:&lt;/i&gt; shows the commands that can be used to further analyze the wait chain of the problematic lock.&#xD;&#xD;Additionally, if the application is instrumented, for instance using the Application Verifier and/or gflags, more fields can be seen in the !analyze extension command result:&#xD;&#xD;&lt;i&gt;NTGLOBALFLAG:&lt;/i&gt; shows the flags enabled by the gflags:&#xD;NTGLOBALFLAG:  0&#xD;In this case, there were not flags enabled for the fault module.&#xD;&#xD;&lt;i&gt;APPLICATION_VERIFIER_FLAGS:&lt;/i&gt; shows the flags enabled using the Application Verifier:&#xD;APPLICATION_VERIFIER_FLAGS:  0&#xD;&#xD;All samples above came from a real crash in the Visual Studio 2010, while I was running my application under debug mode. The application was flagged by both gflags and Application Verifier, but I had not set them for the VS. That means the system had those tools installed. If, on the other hand, the system does not have them, those fields will not appear in the !analyze extension command result.</richText>
  </textBox>
</content>
