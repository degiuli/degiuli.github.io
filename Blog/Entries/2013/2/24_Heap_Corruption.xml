<?xml version="1.0"?>
<content collectionGUID="FB58F55C-9585-4C68-BAD6-2F593DC4614A">
  <lastEdited clientType="local-build-20130324" date="2013-03-24 21:04:12 +0000"/>
  <textBox id="generic-header-attribute" dynamic="no" visible="yes">
    <richText>&lt;a href="perma://BLPageReference/2D085D6A-902D-4579-899A-CF8E11275EFB"&gt;Windows Debugging Series&lt;/a&gt;</richText>
  </textBox>
  <textBox id="generic-title-attributes" dynamic="no" visible="yes">
    <richText>Heap Corruption</richText>
  </textBox>
  <textBox id="generic-datefield-attributes" dynamic="no" visible="yes">
    <richText>24 de fevereiro de 2013</richText>
  </textBox>
  <textBox id="generic-body-attributes" dynamic="no" visible="yes">
    <richText>&lt;i&gt;What is Heap?&lt;/i&gt;&#xD;&#xD;When an application dynamically allocates memory, it can rely on different methods, such as C-runtime heap (using the new/delete and malloc/calloc/realloc/free APIs), the default process heap, or yet application specific heaps (both use heap APIs). Eventually, all reaches the Heap Manager (NTDLL) and then Virtual Memory Manager.&#xD;&#xD;Heap is one form of Windows memory manager, which applications use to allocate and deallocate memory dynamically. Windows Heap has a complex architecture that will not be discussed in much details here. Instead, let&#x2019;s sum up what happens when allocation and freeing a block of memory:&#xD;&#xD;&lt;b&gt;Allocating a block of memory:&lt;/b&gt;&#xD;The Heap manager first consults the front end allocator to see if a free block of memory is available; if it is the heap manager returns it to the caller. Otherwise, the back end allocator&#x2019;s free lists are consulted and:&#xD;If an exact size match is found, flags are updated to indicate that block is busy; the block is then removed from the free list and returned to the caller.&#xD;If an exact size match cannot be found, the heap manager checks to see if a larger block can be split into two smaller blocks that satisfy the request allocation size. If it can, the block is split. One block has the flags updated to a busy state and is returned to the caller. The other block has its flags set to a free state and is added to the free list. The original block is also removed from the free list.&#xD;If the free lists cannot satisfy the allocation request, the heap manager commits more memory from the heap segment, creates a new bloc in the committed range (flags are set to busy state), and returns the block to the caller.&#xD;&#xD;&lt;b&gt;Freeing a block or memory:&#xD;&lt;/b&gt;The front end allocator is consulted to see if it can handle the free block. If the free block is not handled by the front end allocator, heap manager checks if there are any adjacent free block; if so, it coalesces the blocks into one large block by doing the following:&#xD;The adjacent free blocks are removed from the free lists.&#xD;The new large block is added to the free list or front end allocator.&#xD;The flags flags field for the new large block is updated to indicate it is free.&#xD;If no coalescing can be performed, the block is moved into the free list or front end allocator and the flags are updated to a free state.&#xD;&#xD;&lt;b&gt;Some heap info:&lt;/b&gt;&#xD;Front end allocator has two policies on how memory blocks are handle. The first is look aside list (LAL), which is a table of 128 singly linked list. Each singly linked list in the table contains free heap blocks of a specific size starting at 16 bytes plus 8 bytes of metadata used to manage the block. Then, 32 bytes, then 48 bytes, and so on until 1024 bytes, in the last index. The second policy is low fragmentation (LF), which reduces the fragmentation described in LAL. LAL is default in Windows XP and Windows 2003, but the LF is also supported. Windows Vista and later has LF as default. &#xD;Back end allocator contains a table of lists commonly referred to as the free list. The free list&#x2019;s responsibility is to keep track of all the free heap blocks of a specific size.&#xD;&#xD;&lt;i&gt;Accessing Uninitialized Memory&lt;/i&gt;&#xD;&#xD;Accessing uninitialized memory is a common problem in software. Essentially, uninitialized memory refers to a block of memory, for instance a stack variable, that has been successfully allocated but not initialized to a state which is considered valid.&#xD;int main(int argc,char argv[])&#xD;{&#xD;    //allocate stack variable&#xD;    size_t size;&#xD;        &#xD;    //dynamically allocate a memory&#xD;    //using the uninitialized size&#xD;    char pdata = new char[size];&#xD;    if(pdata)&#xD;    {&#xD;        std::cout &lt;&lt; "Data: :"&lt;&lt; pdata &lt;&lt; ", Size: " &lt;&lt; size &lt;&lt; std::endl;&#xD;        //do something...&#xD;        delete [] pdata;&#xD;    }&#xD;    return 0;&#xD;}&#xD;The sample above show two possible problems related to uninitialized memory: (1) when the system allocates the size variable, its memory may contain a value large enough the end up the system memory when pdata is allocated, because the size value is unknown; (2) independently on the value of size, when the std::cout is performed, it is highly likely that it access invalid memory because it will not find the null character in the pdata memory, probably crashing the application. When the system allocates memory to pdata, a pattern is used to fill that new memory and it does not contains a null character.&#xD;&#xD;&lt;i&gt;Heap Overruns and Underruns&lt;/i&gt;&#xD;&#xD;Each heap block, as stated earlier, has a metadata, that is used by the heap manager to properly handle that block. If a faulty piece of code overwrites that data, the heap integrity is compromised and the application will crash. This usually occurs when the block size is not respected and data is written beyond the block boundaries - overruns - or before its initial position - underruns.&#xD;int main(int argc,char argv[])&#xD;{&#xD;    char pdata = new char[100];&#xD;    if(pdata)&#xD;    {&#xD;        //overrun&#xD;        memset(pdata,0x00,110);&#xD;        //underrun&#xD;        memset(&amp;pdata[-10],0x00,100);&#xD;    }&#xD;    return 0;&#xD;}&#xD;Obviously, there is no reason to right such awful code. Let&#x2019;s see a more realistic sample below, in which the input is saved into a internal memory and something (we don&#x2019;t care) is done:&#xD;int main(int argc,char argv[])&#xD;{&#xD;    char pdata = new char[10];&#xD;    if(pdata &amp;&amp; argc&gt;1)&#xD;    {&#xD;        strcpy(pdata,argv[1]);&#xD;        //do something...&#xD;    }&#xD;    if(pdata)&#xD;    {&#xD;        delete [] pdata;&#xD;    }&#xD;    return 0;&#xD;}&#xD;In case the first application argument has more than 10 characters, it will certainly modify memory out of its boundaries. This could certainly corrupt the heap and crash the application.&#xD;&#xD;In addition to the crash and/or heap corruption this could also lead to other consequence that is a security hole. Similarly to the stack overrun, a hacker can also inject a piece of code to gain access to the system by using this technic.&#xD;&#xD;&lt;i&gt;Accessing Freed Memory&lt;/i&gt;&#xD;&#xD;This is also a very common source of heap corruption. After being freed, a block is placed in the free list or front end allocation by the heap manager. From that point, it is considered invalid for application use. If the application uses it in any way, the free list will be corrupted and the application will crash.&#xD;int main(int argc,char argv[])&#xD;{&#xD;    char pdata = new char[10];&#xD;    if(pdata)&#xD;    {&#xD;        //do something...&#xD;        delete [] pdata;&#xD;        &#xD;        //do something more...&#xD;        if(argc&gt;1)&#xD;        {&#xD;            strcpy(pdata,argv[1]);&#xD;        }&#xD;        std::cout &lt;&lt; pdata &lt;&lt; std::endl;&#xD;    }&#xD;    return 0;&#xD;}&#xD;Whether or not there is an application argument, when the pdata is access, the application is access invalid data. In both case, the application is reusing/accessing a freed memory and corrupting the heap.&#xD;&#xD;&lt;i&gt;Double Frees&lt;/i&gt;&#xD;&#xD;An application frees some structure that it had already freed. In such a case, a subsequent reference can pick up a meaningless pointer, causing a heap segmentation violation. Possibly, the application will not crash but this can leads to unpredictable behavior.&#xD;int main(int argc, char argv[])&#xD;{&#xD;    char pdata = new char[10];&#xD;    if(pdata)&#xD;    {&#xD;        //do something...&#xD;        delete [] pdata;&#xD;    }&#xD;    delete [] pdata;&#xD;    return 0;&#xD;}&#xD;&#xD;&lt;i&gt;Erroneous Free&lt;/i&gt;&#xD;&#xD;An application calls an unappropriated memory release method to an addresses. For instance, the application allocates a memory array using new[] but releases it using delete or allocates a memory using malloc and releases it using delete.&#xD;int * int_new = new int;&#xD;delete [] int_new;&#xD;    &#xD;char * char_array = new char[10];&#xD;delete char_array;&#xD;    &#xD;long * long_malloc = (long*)malloc(sizeof(long));&#xD;delete long_malloc;&#xD;    &#xD;double *double_new = new double;&#xD;free(double_new);&#xD;This kind of issue may not lead to a application crash but certainly leads to unpredictable behavior.&#xD;&#xD;&lt;i&gt;Heap Handle Mismatch&lt;/i&gt;&#xD;&#xD;Heap Manager keeps a list of active heaps in a process and an application can have heap handles in addition to the default one. Applications that directly accesses the Heap APIs should be take a extra care while deal with the default - taken from GetProcessHeap API - and possibly internal process heap - created using HeapCreate API.&#xD;&#xD;Allocating memory using in one heap and freeing it using other may not cause visible issue at the moment, but one the mismatch occurs the heap gets corruption which later causes unpredictable behavior and access violation.</richText>
  </textBox>
</content>
