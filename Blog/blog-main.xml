<?xml version="1.0"?>
<rss xmlns:iweb="http://www.apple.com/iweb" version="2.0">
  <channel>
    <title>Blog</title>
    <link>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog</link>
    <description>Welcome the to FLDG blog. FLDG is the acronymous to the name of the blog sponsor. (See About Me to know almost nothing About Me.)
Sometimes, you will see posts in English, alcune volte in Italiano e outras em Portugu&#xEA;s.
Computer (mostly programming) and Natural Science will be the most common posts. But I may write on other subjects.

I hope you enjoy and if you don&#x2019;t, let me know!

Thank you! Grazie! Obrigado!

Twiter: @FabioLDeGiuli
Google+: https://plus.google.com/u/0/100028605799463352770/posts
LonkedIn: http://www.linkedin.com/pub/f%C3%A1bio-louren%C3%A7%C3%A3o-de-giuli/7/990/929</description>
    <item>
      <title>WinDbg Part II</title>
      <link>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/3/10_WinDbg_Part_II.html</link>
      <guid isPermaLink="false">adf98e8b-cd85-4b08-bea0-3d954308a616</guid>
      <pubDate>Sun, 10 Mar 2013 11:33:46 -0300</pubDate>
      <description>This part continues the WinDbg tool discussed start in &lt;a href="Entries/2013/2/1_Debugging_Tools_For_Windows.html"&gt;Debugging Tools For Windows&lt;/a&gt; post and shows additional commands that helps analyze issue in addition to the !analyze command introduced in &lt;a href="Entries/2013/2/8_WinDbg_Part_I.html"&gt;WinDbg Part I&lt;/a&gt; post.&lt;br/&gt;&lt;br/&gt;The number of command and its parameter are huge and they can be seen through the WinDbg help. This post will introduce few useful commands and some of them options. All options listed here should be executed in the WinDbg window command line. Finally, the list is not particularly grouped.&lt;br/&gt;&lt;br/&gt;List of Commands&lt;br/&gt;&lt;br/&gt;~&lt;br/&gt;This command list all thread, its state, id and environment block address (TEB). The . (as highlighted below) indicates which thread was running when the debug stopped or dump was created.&lt;br/&gt;0:036&gt; ~&lt;br/&gt;   0  Id: 109c.1700 Suspend: 0 Teb: 7ffdf000 Unfrozen&lt;br/&gt;   1  Id: 109c.3ac Suspend: 0 Teb: 7ffdb000 Unfrozen&lt;br/&gt;   2  Id: 109c.86c Suspend: 0 Teb: 7ffd9000 Unfrozen&lt;br/&gt;   3  Id: 109c.b90 Suspend: 0 Teb: 7ffd8000 Unfrozen&lt;br/&gt;   4  Id: 109c.e58 Suspend: 0 Teb: 7ffd6000 Unfrozen&lt;br/&gt;   5  Id: 109c.156c Suspend: 0 Teb: 7ffd5000 Unfrozen&lt;br/&gt;   6  Id: 109c.2e4 Suspend: 0 Teb: 7ff4f000 Unfrozen&lt;br/&gt;   7  Id: 109c.14dc Suspend: 0 Teb: 7ff4e000 Unfrozen&lt;br/&gt;   8  Id: 109c.1400 Suspend: 0 Teb: 7ff4d000 Unfrozen&lt;br/&gt;   9  Id: 109c.e50 Suspend: 0 Teb: 7ff4c000 Unfrozen&lt;br/&gt;  10  Id: 109c.fe4 Suspend: 0 Teb: 7ff4a000 Unfrozen&lt;br/&gt;  11  Id: 109c.1180 Suspend: 0 Teb: 7ff48000 Unfrozen&lt;br/&gt;  12  Id: 109c.8a8 Suspend: 0 Teb: 7ff47000 Unfrozen&lt;br/&gt;  13  Id: 109c.1428 Suspend: 0 Teb: 7ffdd000 Unfrozen&lt;br/&gt;  14  Id: 109c.be4 Suspend: 0 Teb: 7ff4b000 Unfrozen&lt;br/&gt;  15  Id: 109c.e30 Suspend: 0 Teb: 7ff42000 Unfrozen&lt;br/&gt;  16  Id: 109c.11ac Suspend: 0 Teb: 7ff41000 Unfrozen&lt;br/&gt;  17  Id: 109c.a78 Suspend: 0 Teb: 7ff40000 Unfrozen&lt;br/&gt;  18  Id: 109c.1354 Suspend: 0 Teb: 7ff3f000 Unfrozen&lt;br/&gt;  19  Id: 109c.eec Suspend: 0 Teb: 7ff3e000 Unfrozen&lt;br/&gt;  20  Id: 109c.1454 Suspend: 0 Teb: 7ff3d000 Unfrozen&lt;br/&gt;  21  Id: 109c.1768 Suspend: 0 Teb: 7ff3c000 Unfrozen&lt;br/&gt;  22  Id: 109c.1474 Suspend: 0 Teb: 7ff3b000 Unfrozen&lt;br/&gt;  23  Id: 109c.14ac Suspend: 0 Teb: 7ff3a000 Unfrozen&lt;br/&gt;  24  Id: 109c.11f8 Suspend: 0 Teb: 7ff39000 Unfrozen&lt;br/&gt;  25  Id: 109c.8cc Suspend: 0 Teb: 7ff38000 Unfrozen&lt;br/&gt;  26  Id: 109c.b80 Suspend: 0 Teb: 7ff34000 Unfrozen&lt;br/&gt;  27  Id: 109c.1188 Suspend: 0 Teb: 7ff33000 Unfrozen&lt;br/&gt;  28  Id: 109c.17f4 Suspend: 0 Teb: 7ff32000 Unfrozen&lt;br/&gt;  29  Id: 109c.d50 Suspend: 0 Teb: 7ff31000 Unfrozen&lt;br/&gt;  30  Id: 109c.820 Suspend: 0 Teb: 7ff43000 Unfrozen&lt;br/&gt;  31  Id: 109c.13dc Suspend: 0 Teb: 7ff2d000 Unfrozen&lt;br/&gt;  32  Id: 109c.11fc Suspend: 0 Teb: 7ff2c000 Unfrozen&lt;br/&gt;  33  Id: 109c.48c Suspend: 0 Teb: 7ff2a000 Unfrozen&lt;br/&gt;  34  Id: 109c.4c4 Suspend: 0 Teb: 7ff29000 Unfrozen&lt;br/&gt;  35  Id: 109c.264 Suspend: 0 Teb: 7ff28000 Unfrozen&lt;br/&gt;. 36  Id: 109c.c30 Suspend: 0 Teb: 7ff44000 Unfrozen&lt;br/&gt;  37  Id: 109c.124c Suspend: 0 Teb: 7ff27000 Unfrozen&lt;br/&gt;  38  Id: 109c.938 Suspend: 0 Teb: 7ff49000 Unfrozen&lt;br/&gt;  39  Id: 109c.1228 Suspend: 0 Teb: 7ffd7000 Unfrozen&lt;br/&gt;  40  Id: 109c.fac Suspend: 0 Teb: 7ff36000 Unfrozen&lt;br/&gt;  41  Id: 109c.20e0 Suspend: 0 Teb: 7ffde000 Unfrozen&lt;br/&gt;  42  Id: 109c.1090 Suspend: 0 Teb: 7ff30000 Unfrozen&lt;br/&gt;  43  Id: 109c.25bc Suspend: 0 Teb: 7ff1f000 Unfrozen&lt;br/&gt;  44  Id: 109c.26b4 Suspend: 0 Teb: 7ff37000 Unfrozen&lt;br/&gt;  45  Id: 109c.6c4 Suspend: 0 Teb: 7ff26000 Unfrozen&lt;br/&gt;  46  Id: 109c.1a6c Suspend: 0 Teb: 7ffdc000 Unfrozen&lt;br/&gt;  47  Id: 109c.b2c Suspend: 0 Teb: 7ff2e000 Unfrozen&lt;br/&gt;  48  Id: 109c.1da8 Suspend: 0 Teb: 7ff45000 Unfrozen&lt;br/&gt;&lt;br/&gt;This command has few interesting parameters, such as ~~[PID] that gives information from a specific thread.&lt;br/&gt;&lt;br/&gt;kP [number]&lt;br/&gt;This command collects the stack of the current from the last instruction to the [number]th instruction. If [number] is 10, the command will listed only the last 10 instructions. What is really interesting with this command is that it may be able to retrieve the list of parameters and its contents in addition to the common k command (which retrieves the stack, function address and the source line info when available).&lt;br/&gt;&lt;br/&gt;This command can also be combined with thread commands to evaluate stack of all thread form instance: ~*kP 100.&lt;br/&gt;&lt;br/&gt;.ecxr&lt;br/&gt;This command directs the debugger to the exception context, i.e. to the thread and instruction that caused the exception, when this is the case. It reports the registers states, the function address and the assembly instruction that caused the exception. After executing this command, the kP command retrieves the exactly stack of the the failed thread.&lt;br/&gt;Most of the cases, the !analyze -v command, points to the correct exception context. However, during the debugging process, this context can be far way and this command set it back. Additionally, there are few times the !analyze -v command does not end the exception context. So applying this command will help much.&lt;br/&gt;&lt;br/&gt;d[opt] &amp;lt;address&gt; command set&lt;br/&gt;The d commands are a set of commands that retrieve the state of the memory address. Each existent [opt] of d command set display a memory range in different mode:&lt;br/&gt;da - ASCII form                                        du - Unicode form&lt;br/&gt;&lt;br/&gt;db - byte and ASCII form:&lt;br/&gt;0:000&gt; db 0x0984ad38&lt;br/&gt;0984ad38  50 65 72 20 66 61 72 65-20 75 6e 61 20 73 65 67  Per fare una seg&lt;br/&gt;0984ad48  6e 61 6c 61 7a 69 6f 6e-65 20 6f 20 70 6f 72 72  nalazione o porr&lt;br/&gt;0984ad58  65 20 75 6e 61 20 64 6f-6d 61 6e 64 61 2c 20 63  e una domanda, c&lt;br/&gt;0984ad68  6f 6e 74 61 74 74 61 72-65 20 75 6e 61 20 64 65  ontattare una de&lt;br/&gt;0984ad78  6c 6c 65 0d 0a 73 65 67-75 65 6e 74 69 20 72 69  lle..seguenti ri&lt;br/&gt;0984ad88  73 6f 72 73 65 20 61 7a-69 65 6e 64 61 6c 69 3a  sorse aziendali:&lt;br/&gt;0984ad98  0d 0a 2e 2e 20 49 6c 20-74 75 6f 20 73 75 70 65  .... Il tuo supe&lt;br/&gt;0984ada8  72 76 69 73 6f 72 65 20-6f 20 75 6e 20 61 6c 74  rvisore o un alt&lt;br/&gt;&lt;br/&gt;dw - 2-byte word                                       dW - 2-bytes word and ASCII&lt;br/&gt;dd - 4-byte double word                            dc - 4-byte double word and ASCII&lt;br/&gt;dq - 8-byte quad word&lt;br/&gt;&lt;br/&gt;dyb - binary and byte form:&lt;br/&gt;0:000&gt; dyb 0x0984ad38&lt;br/&gt;          76543210 76543210 76543210 76543210&lt;br/&gt;          -------- -------- -------- --------&lt;br/&gt;0984ad38  01010000 01100101 01110010 00100000  50 65 72 20&lt;br/&gt;0984ad3c  01100110 01100001 01110010 01100101  66 61 72 65&lt;br/&gt;0984ad40  00100000 01110101 01101110 01100001  20 75 6e 61&lt;br/&gt;0984ad44  00100000 01110011 01100101 01100111  20 73 65 67&lt;br/&gt;0984ad48  01101110 01100001 01101100 01100001  6e 61 6c 61&lt;br/&gt;0984ad4c  01111010 01101001 01101111 01101110  7a 69 6f 6e&lt;br/&gt;0984ad50  01100101 00100000 01101111 00100000  65 20 6f 20&lt;br/&gt;0984ad54  01110000 01101111 01110010 01110010  70 6f 72 72&lt;br/&gt;&lt;br/&gt;dyd - binary and 4-byte double word&lt;br/&gt;&lt;br/&gt;It is possible to continue looking at the memory block by typing the same command. For instance, after typing db 0x0984ad38, the db without address will show the next block from 0984ada8+0x10:&lt;br/&gt;0984adb8  72 6f 20 6d 65 6d 62 72-6f 20 64 65 6c 6c 61 20  ro membro della &lt;br/&gt;0984adc8  64 69 72 69 67 65 6e 7a-61 20 61 7a 69 65 6e 64  dirigenza aziend&lt;br/&gt;0984add8  61 6c 65 0d 0a 2e 2e 20-55 6e 20 72 61 70 70 72  ale.... Un rappr&lt;br/&gt;0984ade8  65 73 65 6e 74 61 6e 74-65 20 64 65 6c 6c 65 20  esentante delle &lt;br/&gt;0984adf8  72 69 73 6f 72 73 65 20-75 6d 61 6e 65 0d 0a 2e  risorse umane...&lt;br/&gt;0984ae08  2e 20 55 6e 20 43 68 69-65 66 20 43 6f 6d 70 6c  . Un Chief Compl&lt;br/&gt;0984ae18  69 61 6e 63 65 20 4f 66-66 69 63 65 72 20 28 72  iance Officer (r&lt;br/&gt;0984ae28  65 73 70 6f 6e 73 61 62-69 6c 65 20 70 65 72 20  esponsabile per &lt;br/&gt;&lt;br/&gt;This is possible for all d command set.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Interesting Sequence&lt;br/&gt;&lt;br/&gt;After having shown some commands and options, how would they be used together? The answer depends on which sort of error. In any case, however, there is an interesting sequence that can be used to after the !analyze -v command. The sequence is:&lt;br/&gt;.ecxr                            go to the exception context - may not be needed&lt;br/&gt;kP 100                         last 100 calls on the stack&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Conclusion&lt;br/&gt;&lt;br/&gt;Beside the commands and options shown above, the Internet has a vast number of useful sites and blogs that provider further information, tips and tricks, such as:&lt;br/&gt;&lt;br/&gt;ntdebugging - Advanced Windows Debugging and Troubleshooting from MSDN:&lt;br/&gt;&lt;a href="http://blogs.msdn.com/b/ntdebugging/"&gt;http://blogs.msdn.com/b/ntdebugging/&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;Crash Dump Analysis:&lt;br/&gt;&lt;a href="http://www.dumpanalysis.org/blog/"&gt;http://www.dumpanalysis.org/blog/&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;Both sites about has much more information than simply a list of commands. They also show how to use them, inform details about the error, etc.&lt;br/&gt;&lt;br/&gt;Common WinDbg Commands (Thematically Grouped)&lt;br/&gt;&lt;a href="http://windbg.info/doc/1-common-cmds.html"&gt;http://windbg.info/doc/1-common-cmds.html&lt;/a&gt;&lt;br/&gt;&lt;br/&gt;This one is basically the same information found in the WinDbg help, but in one single page. Additionally, this site has a &lt;a href="http://windbg.info/forum/10-windbg-related-discussions.html"&gt;forum&lt;/a&gt; about related to WinDbg, but it may not be so useful as expected.</description>
      <iweb:comment enabled="0" count="0" link="file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/3/10_WinDbg_Part_II.html#comment_layer"></iweb:comment>
    </item>
    <item>
      <title>Heap Corruption</title>
      <link>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/24_Heap_Corruption.html</link>
      <guid isPermaLink="false">046d0673-9c73-43da-98cf-20d44e638f40</guid>
      <pubDate>Sun, 24 Feb 2013 11:51:24 -0300</pubDate>
      <description>What is Heap?&lt;br/&gt;&lt;br/&gt;When an application dynamically allocates memory, it can rely on different methods, such as C-runtime heap (using the new/delete and malloc/calloc/realloc/free APIs), the default process heap, or yet application specific heaps (both use heap APIs). Eventually, all reaches the Heap Manager (NTDLL) and then Virtual Memory Manager.&lt;br/&gt;&lt;br/&gt;Heap is one form of Windows memory manager, which applications use to allocate and deallocate memory dynamically. Windows Heap has a complex architecture that will not be discussed in much details here. Instead, let&#x2019;s sum up what happens when allocation and freeing a block of memory:&lt;br/&gt;&lt;br/&gt;Allocating a block of memory:&lt;br/&gt;The Heap manager first consults the front end allocator to see if a free block of memory is available; if it is the heap manager returns it to the caller. Otherwise, the back end allocator&#x2019;s free lists are consulted and:&lt;br/&gt;If an exact size match is found, flags are updated to indicate that block is busy; the block is then removed from the free list and returned to the caller.&lt;br/&gt;If an exact size match cannot be found, the heap manager checks to see if a larger block can be split into two smaller blocks that satisfy the request allocation size. If it can, the block is split. One block has the flags updated to a busy state and is returned to the caller. The other block has its flags set to a free state and is added to the free list. The original block is also removed from the free list.&lt;br/&gt;If the free lists cannot satisfy the allocation request, the heap manager commits more memory from the heap segment, creates a new bloc in the committed range (flags are set to busy state), and returns the block to the caller.&lt;br/&gt;&lt;br/&gt;Freeing a block or memory:&lt;br/&gt;The front end allocator is consulted to see if it can handle the free block. If the free block is not handled by the front end allocator, heap manager checks if there are any adjacent free block; if so, it coalesces the blocks into one large block by doing the following:&lt;br/&gt;The adjacent free blocks are removed from the free lists.&lt;br/&gt;The new large block is added to the free list or front end allocator.&lt;br/&gt;The flags flags field for the new large block is updated to indicate it is free.&lt;br/&gt;If no coalescing can be performed, the block is moved into the free list or front end allocator and the flags are updated to a free state.&lt;br/&gt;&lt;br/&gt;Some heap info:&lt;br/&gt;Front end allocator has two policies on how memory blocks are handle. The first is look aside list (LAL), which is a table of 128 singly linked list. Each singly linked list in the table contains free heap blocks of a specific size starting at 16 bytes plus 8 bytes of metadata used to manage the block. Then, 32 bytes, then 48 bytes, and so on until 1024 bytes, in the last index. The second policy is low fragmentation (LF), which reduces the fragmentation described in LAL. LAL is default in Windows XP and Windows 2003, but the LF is also supported. Windows Vista and later has LF as default. &lt;br/&gt;Back end allocator contains a table of lists commonly referred to as the free list. The free list&#x2019;s responsibility is to keep track of all the free heap blocks of a specific size.&lt;br/&gt;&lt;br/&gt;Accessing Uninitialized Memory&lt;br/&gt;&lt;br/&gt;Accessing uninitialized memory is a common problem in software. Essentially, uninitialized memory refers to a block of memory, for instance a stack variable, that has been successfully allocated but not initialized to a state which is considered valid.&lt;br/&gt;int main(int argc,char argv[])&lt;br/&gt;{&lt;br/&gt;    //allocate stack variable&lt;br/&gt;    size_t size;&lt;br/&gt;&lt;br/&gt;    //dynamically allocate a memory&lt;br/&gt;    //using the uninitialized size&lt;br/&gt;    char pdata = new char[size];&lt;br/&gt;    if(pdata)&lt;br/&gt;    {&lt;br/&gt;        std::cout &amp;lt;&amp;lt; "Data: :"&amp;lt;&amp;lt; pdata &amp;lt;&amp;lt; ", Size: " &amp;lt;&amp;lt; size &amp;lt;&amp;lt; std::endl;&lt;br/&gt;        //do something...&lt;br/&gt;        delete [] pdata;&lt;br/&gt;    }&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;br/&gt;The sample above show two possible problems related to uninitialized memory: (1) when the system allocates the size variable, its memory may contain a value large enough the end up the system memory when pdata is allocated, because the size value is unknown; (2) independently on the value of size, when the std::cout is performed, it is highly likely that it access invalid memory because it will not find the null character in the pdata memory, probably crashing the application. When the system allocates memory to pdata, a pattern is used to fill that new memory and it does not contains a null character.&lt;br/&gt;&lt;br/&gt;Heap Overruns and Underruns&lt;br/&gt;&lt;br/&gt;Each heap block, as stated earlier, has a metadata, that is used by the heap manager to properly handle that block. If a faulty piece of code overwrites that data, the heap integrity is compromised and the application will crash. This usually occurs when the block size is not respected and data is written beyond the block boundaries - overruns - or before its initial position - underruns.&lt;br/&gt;int main(int argc,char argv[])&lt;br/&gt;{&lt;br/&gt;    char pdata = new char[100];&lt;br/&gt;    if(pdata)&lt;br/&gt;    {&lt;br/&gt;        //overrun&lt;br/&gt;        memset(pdata,0x00,110);&lt;br/&gt;        //underrun&lt;br/&gt;        memset(&amp;amp;pdata[-10],0x00,100);&lt;br/&gt;    }&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;br/&gt;Obviously, there is no reason to right such awful code. Let&#x2019;s see a more realistic sample below, in which the input is saved into a internal memory and something (we don&#x2019;t care) is done:&lt;br/&gt;int main(int argc,char argv[])&lt;br/&gt;{&lt;br/&gt;    char pdata = new char[10];&lt;br/&gt;    if(pdata &amp;amp;&amp;amp; argc&gt;1)&lt;br/&gt;    {&lt;br/&gt;        strcpy(pdata,argv[1]);&lt;br/&gt;        //do something...&lt;br/&gt;    }&lt;br/&gt;    if(pdata)&lt;br/&gt;    {&lt;br/&gt;        delete [] pdata;&lt;br/&gt;    }&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;br/&gt;In case the first application argument has more than 10 characters, it will certainly modify memory out of its boundaries. This could certainly corrupt the heap and crash the application.&lt;br/&gt;&lt;br/&gt;In addition to the crash and/or heap corruption this could also lead to other consequence that is a security hole. Similarly to the stack overrun, a hacker can also inject a piece of code to gain access to the system by using this technic.&lt;br/&gt;&lt;br/&gt;Accessing Freed Memory&lt;br/&gt;&lt;br/&gt;This is also a very common source of heap corruption. After being freed, a block is placed in the free list or front end allocation by the heap manager. From that point, it is considered invalid for application use. If the application uses it in any way, the free list will be corrupted and the application will crash.&lt;br/&gt;int main(int argc,char argv[])&lt;br/&gt;{&lt;br/&gt;    char pdata = new char[10];&lt;br/&gt;    if(pdata)&lt;br/&gt;    {&lt;br/&gt;        //do something...&lt;br/&gt;        delete [] pdata;&lt;br/&gt;&lt;br/&gt;        //do something more...&lt;br/&gt;        if(argc&gt;1)&lt;br/&gt;        {&lt;br/&gt;            strcpy(pdata,argv[1]);&lt;br/&gt;        }&lt;br/&gt;        std::cout &amp;lt;&amp;lt; pdata &amp;lt;&amp;lt; std::endl;&lt;br/&gt;    }&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;br/&gt;Whether or not there is an application argument, when the pdata is access, the application is access invalid data. In both case, the application is reusing/accessing a freed memory and corrupting the heap.&lt;br/&gt;&lt;br/&gt;Double Frees&lt;br/&gt;&lt;br/&gt;An application frees some structure that it had already freed. In such a case, a subsequent reference can pick up a meaningless pointer, causing a heap segmentation violation. Possibly, the application will not crash but this can leads to unpredictable behavior.&lt;br/&gt;int main(int argc, char argv[])&lt;br/&gt;{&lt;br/&gt;    char pdata = new char[10];&lt;br/&gt;    if(pdata)&lt;br/&gt;    {&lt;br/&gt;        //do something...&lt;br/&gt;        delete [] pdata;&lt;br/&gt;    }&lt;br/&gt;    delete [] pdata;&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Erroneous Free&lt;br/&gt;&lt;br/&gt;An application calls an unappropriated memory release method to an addresses. For instance, the application allocates a memory array using new[] but releases it using delete or allocates a memory using malloc and releases it using delete.&lt;br/&gt;int * int_new = new int;&lt;br/&gt;delete [] int_new;&lt;br/&gt;&lt;br/&gt;char * char_array = new char[10];&lt;br/&gt;delete char_array;&lt;br/&gt;&lt;br/&gt;long * long_malloc = (long*)malloc(sizeof(long));&lt;br/&gt;delete long_malloc;&lt;br/&gt;&lt;br/&gt;double *double_new = new double;&lt;br/&gt;free(double_new);&lt;br/&gt;This kind of issue may not lead to a application crash but certainly leads to unpredictable behavior.&lt;br/&gt;&lt;br/&gt;Heap Handle Mismatch&lt;br/&gt;&lt;br/&gt;Heap Manager keeps a list of active heaps in a process and an application can have heap handles in addition to the default one. Applications that directly accesses the Heap APIs should be take a extra care while deal with the default - taken from GetProcessHeap API - and possibly internal process heap - created using HeapCreate API.&lt;br/&gt;&lt;br/&gt;Allocating memory using in one heap and freeing it using other may not cause visible issue at the moment, but one the mismatch occurs the heap gets corruption which later causes unpredictable behavior and access violation.</description>
      <iweb:comment enabled="0" count="0" link="file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/24_Heap_Corruption.html#comment_layer"></iweb:comment>
    </item>
    <item>
      <title>Stack Corruption</title>
      <link>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/24_Stack_Corruption.html</link>
      <guid isPermaLink="false">21234798-0b40-4094-8cc5-cfbbf91917f5</guid>
      <pubDate>Sun, 24 Feb 2013 11:49:57 -0300</pubDate>
      <description>What is a Stack?&lt;br/&gt;&lt;br/&gt;Stack is one of the most common data structure. It is pretty simple data structure that can be equated to a stack of plates or papers, where you push a new on top of it and pop from the top of it. The top is the next to be pushed or popped. In computers, the stack is in fact the lower addresses. One very good clarification about stack is the &lt;a href="http://eli.thegreenplace.net/2011/02/04/where-the-top-of-the-stack-is-on-x86/"&gt;Where the top of the stack is on x86&lt;/a&gt; post from Eli Bendersky&#x2019;s blog.&lt;br/&gt;&lt;br/&gt;In Windows system, stack is just a block of memory assigned by the operating system to a running thread. The stack is also used to track the function calls chain, including allocation of local variables and parameter passing. Once a function is called, a new frame is created on the stack and it will grows bigger and bigger as more and more functions are called. The way a function call grows in the stack depends on the CPU architecture (x86, ARM, RISC, PowerPC). The x86, which will be the focus of our discussion, has some calling conventions that directly affect how the data is placed on the stack. &lt;br/&gt;&lt;br/&gt;x86 Calling Convention&lt;br/&gt;&lt;br/&gt;Now, let&#x2019;s look at the x86 architecture calling convention. This information may be important to understand what a dump file can show. This will also describe the how a stack is filled and the function decoration (how the compiler and linker builds the name of a function). Also, calling conventions is nothing more than a contract between the caller and callee functions. It specifies rules that both must agree.&lt;br/&gt;&lt;br/&gt;The most important types of calling conventions are:&lt;br/&gt;&lt;br/&gt;cdecl&lt;br/&gt;cdecl, or C declaration, originates from the C language and is defined at __cdecl. Caller function should clear the stack. Parameters will be passed by via stack from right (on the top) to left (on the bottom). Also, the function will be prefixed by &#x2018;_&#x2019;.&lt;br/&gt;&lt;br/&gt;Let&#x2019;s look at the sample below:&lt;br/&gt;int __cdecl callee(int, int, int);&lt;br/&gt;&lt;br/&gt;int __cdecl caller(void)&lt;br/&gt;{&lt;br/&gt;	int ret;&lt;br/&gt;&lt;br/&gt;	ret = callee(1,2,3);&lt;br/&gt;	ret += 5;&lt;br/&gt;	return ret;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Using the assembly code, the caller will firstly, push the 3 to stack, then 2 and finally 1 before call the callee function:&lt;br/&gt;push    $3&lt;br/&gt;push    $2&lt;br/&gt;push    $1&lt;br/&gt;call	    _callee&lt;br/&gt;&lt;br/&gt;There are also few details about the registers that should be manipulated in that operation, which also depends on the type of the parameter. There are a vast number of sources that you can look for more details about this information.&lt;br/&gt;&lt;br/&gt;stdcall&lt;br/&gt;stdcall is basically used by Win32, with exceptions for variadic functions, and is defined as __stdcall. Similar to the cdecl, it uses the stack to pass parameter, also from left to right, but it is no longer reponsible for cleaning up the stack; the called function should clear stack. Function name are decorated with &#x2018;_&#x2019; appended by &#x2018;@&#x2019; followed by the number of bytes of stack space required.&lt;br/&gt;Back to the callee sample above:&lt;br/&gt;int __stdcall callee(int, int, int);&lt;br/&gt;it decorated name would be: _callee@12, because each int parameter has 4 bytes.&lt;br/&gt;&lt;br/&gt;fastcall&lt;br/&gt;fastcall, defined as __fastcall, is quite similar to the stdcall, except that the first two parameters is passed on ECX and EDX registers and the other are passed by stack. The called function is responsible to clear the stack and its decoration is exactly the same as stdcall.&lt;br/&gt;&lt;br/&gt;thiscall&lt;br/&gt;This is default convention for for C++ member functions that do not use variable arguments. The first parameter, which is the &#x2018;this&#x2019; parameter, is passed in ECX register, with the remainder passed on the stack as in stdcall. As stdcall, the called function is responsible to clear the stack. The function names are decorated by the C++ compiler in an extremely complicated mechanism that encodes the type of each parameter, among other things. This is necessary because C++ permits function overloading, so a complex decoration scheme must be used so that the various overloads have different decorated names. One interesting post about the C++ decorate names is &lt;a href="http://mearie.org/documents/mscmangle/"&gt;Microsoft C++ Name Mangling Scheme&lt;/a&gt;. There are more details in &lt;a href="http://msdn.microsoft.com/en-us/library/56h2zst2.aspx"&gt;MSDN&lt;/a&gt;.&lt;br/&gt;&lt;br/&gt;Calling Conventions Mismatch&lt;br/&gt;&lt;br/&gt;Now that stack is no longer an obscure thing in software processing, let&#x2019;s start looking some stack issues. The first is the calling conventions mismatch. As introduced earlier, the different types of calling conventions lead to different way the stack is manipulated. Both caller and callee functions must agree with the rules. Let&#x2019;s suppose there is DLL with one function:&lt;br/&gt;void __stdcall DllProc(int);&lt;br/&gt;that prints the argument and we also have an application that dynamically loads the DLL and executes the function:&lt;br/&gt;typedef int (__cdecl *DLLPROC)(int);&lt;br/&gt;&lt;br/&gt;void CallProc(DLLPROC pProc,int arg)&lt;br/&gt;{&lt;br/&gt;    pProc(arg);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int __cdecl main(int argc,char *argv[])&lt;br/&gt;{&lt;br/&gt;    HMODULE hMod = LoadLibrary("DLL.dll");&lt;br/&gt;    if(mod)&lt;br/&gt;    {&lt;br/&gt;        DLLPROC pProc = (DLLPROC)GetProcAddress(hMod,"DllProc");&lt;br/&gt;        if(pProc)&lt;br/&gt;        {&lt;br/&gt;            CallProc(pProc,argc);&lt;br/&gt;        }&lt;br/&gt;        FreeLibrary(hMod);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;The code is can be compiled and linked. Running the application may not cause any issue and there will be an output but would not be the expected one simply because the calling conventions. The main function will not expect the DLL!DllProc to cleanup the stack, but it will as defined as __stdcall. Before the DLL!DllProc returns, it is responsible to cleanup the stack, which means it will modify the registers accordingly. However, the main function will also perform the same operation because it believes the DLL!DllProc will not do it due to the fact the function pointer is set as __cdecl.&lt;br/&gt;&lt;br/&gt;This modifies the stack and causes unpredictable issues. In this specific case, it may probably run the DLL!DllProc again. If this example is run under a debugger, this will show an exception.&lt;br/&gt;&lt;br/&gt;Stack Overrun&lt;br/&gt;&lt;br/&gt;Stack overrun, also know as buffer overflow or stack buffer overflow, occurs when a thread indiscriminately overwrites portions of its call stack reserved for other purpose. Examples of this issue are overwriting the return address for a particular frame, overwriting entire frame, exhausting the stack completely. The effects of stack overrun range from crash, unpredictable behavior and even critical security holes.&lt;br/&gt;&lt;br/&gt;One common mistake that causes this issue is copying a string to a smaller area. Take the following sample code below:&lt;br/&gt;void foo(char *pdata)&lt;br/&gt;{&lt;br/&gt;    char data[10] = {0};    //stack memory&lt;br/&gt;    strcpy(data,pdata);&lt;br/&gt;    std::cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; std::endl;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;int main(int argc, char *argv[])&lt;br/&gt;{&lt;br/&gt;    if(argc&gt;1)&lt;br/&gt;    {&lt;br/&gt;        //pass first argument to function&lt;br/&gt;        foo(argv[1]);&lt;br/&gt;    }&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;br/&gt;What would happen if the argv[1] string is bigger than 10 bytes? A crash would occur because the characters beyond the 10th position, characters out of the allocated memory boundaries, would write the stack memory changing its contents, causing this memory to be invalid. If this memory is, for instance, an instruction address, it can certainly redirect the application execution to wrong path. So, the consequence is a security hole. A hacker can inject a piece of code to gain access to the system by using this technic.&lt;br/&gt;&lt;br/&gt;Stack Overflow&lt;br/&gt;&lt;br/&gt;Stack overflow usually occurs when too much memory is used on stack, which contains a limited amount of memory. The memory size available on stack depends on the language used, the machine architecture, multi-threading, and the amount memory available. When an application attempts to allocate more stack memory that available, it typically crashes as a result of the overflow. The two main reason that results in stack overflow are:&lt;br/&gt;very or infinite recursion:&lt;br/&gt;int foo();&lt;br/&gt;{&lt;br/&gt;    return foo();&lt;br/&gt;}&lt;br/&gt;very large stack variable:&lt;br/&gt;int foo();&lt;br/&gt;{&lt;br/&gt;    double very_large_array[1000000];&lt;br/&gt;    //do something ...&lt;br/&gt;    return something...;&lt;br/&gt;}&lt;br/&gt;There are two basic rules to avoid this issue: (1) be care when doing recursion, always verifying completely the out case there is no infinite recursion or it is called so many times; (2) do not use much stack variable by allocating any variable greater than 256 bytes.&lt;br/&gt;&lt;br/&gt;Stack Underrun&lt;br/&gt;&lt;br/&gt;Stack underrun errors as less common, but it can occurs when the stack to be read becomes empty.</description>
      <iweb:comment enabled="0" count="0" link="file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/24_Stack_Corruption.html#comment_layer"></iweb:comment>
    </item>
    <item>
      <title>Memory Corruption</title>
      <link>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/23_Memory_Corruption.html</link>
      <guid isPermaLink="false">ca876be3-f8df-4bc4-84c7-2f297084e790</guid>
      <pubDate>Sat, 23 Feb 2013 22:12:06 -0300</pubDate>
      <description>Errors in running application depends on the type of language in which is written, i.e. whether is a safe language like Java and C# or an unsafe language like C and C++. (C and C++ are the focus language of this series.)&lt;br/&gt;&lt;br/&gt;Unsafe languages can lead to &#x201C;undefined behavior&#x201D;, in which &#x201C;Anything at all can happen; the Standard imposes no requirements. The program may fail to compile, or it may execute incorrectly (either crashing or silently generating incorrect results), or it may fortuitously do exactly what the programmer intended.&#x201D; as stated in C FAQ.&lt;br/&gt;&lt;br/&gt;Basically, memory corruption is what the undefined behavior means. It refers to any issue that affects an application memory. It is one of the most intractable forms of programming error either because the source of the issue and its manifestation might be far apart or because its symptoms appear under unusual conditions.&lt;br/&gt;&lt;br/&gt;Memory corruption may happen at least one of the following conditions take place:&lt;br/&gt;The executing thread writes to a black of memory that it does not own.&lt;br/&gt;The executing thread writes to a block of memory the it does own but corrupts its state or other application memory block state.&lt;br/&gt;&lt;br/&gt;In any case an exception is generated and this can cause application to crash. If there is no crash, application enters in an unpredictable behavior:&lt;br/&gt;&lt;br/&gt;Application crashes&lt;br/&gt;An application crash stops its execution because it may write to memory consider invalid by the operating system. In some cases, the writing may be considered valid, but it modifies the application state. Subsequently, the application might try to use the memory incorrectly written and the crash can happen depending on the memory access.&lt;br/&gt;&lt;br/&gt;Unpredictable behavior&lt;br/&gt;An application may write bad data to the memory owned by other parts of the application, which might not cause the crash. When other part of the application access the bad data written, it changes is state in an unpredictable way which leads to unpredictable behavior, such as processing wrong instructions, show incorrect data, etc.&lt;br/&gt;&lt;br/&gt;There are two common issue that represent the memory corruptions: &lt;a href="Entries/2013/2/24_Stack_Corruption.html"&gt;Stack Corruption&lt;/a&gt; and &lt;a href="Entries/2013/2/24_Heap_Corruption.html"&gt;Heap Corruption&lt;/a&gt;. Both will be discussed in later posts, but firstly we shall discuss how we can detect and fix memory corruption issues.&lt;br/&gt;&lt;br/&gt;How do Detect Memory Corruption&lt;br/&gt;&lt;br/&gt;Detecting and fixing a memory corruption issue is at minimum difficult. Some occurrence can be so difficult that we may spend months looking for a solution.&lt;br/&gt;&lt;br/&gt;The first one is the analysis, which consist on collect data, such as application trace, dump files and source code, when available. The tools needed to analyze the dump will be discussed in later posts.&lt;br/&gt;&lt;br/&gt;Source code can be followed while the traces and dumps are analyzed. This helps to understand what behavior was expected and was not performed, which function/method was performed before occurred the exception.&lt;br/&gt;&lt;br/&gt;Based on the data collected, one can go deeper into the source code, analyzing the behavior expected and what occurred when the issue happened. One can also use a debugger tool and/or instrument the source code to test it again the conditions the application crashed. Unfortunately, lots of those conditions are certainly not easily reproduced. Tools that instrument source code and debugger tools will also be discussed in later posts.&lt;br/&gt;</description>
      <iweb:comment enabled="0" count="0" link="file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/23_Memory_Corruption.html#comment_layer"></iweb:comment>
    </item>
    <item>
      <title>WinDbg Part I</title>
      <link>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/8_WinDbg_Part_I.html</link>
      <guid isPermaLink="false">9ab9878c-254e-484c-9da7-551431324b22</guid>
      <pubDate>Fri, 8 Feb 2013 20:17:23 -0200</pubDate>
      <description>As part of the Debugging Tools for Windows, WinDbg is a very known debugging tool that can use for both live and postmortem debug, user and kernel mode with a graphical user interface.&lt;br/&gt;&lt;br/&gt;The focus of this command will be the !analyze extension command. Its goals is to automatic analyze failures, detecting and assigning to known problems of dumps. Its parameters are:&lt;br/&gt;!analyze -v or !analyze -v -hang. The former is used for crash dumps and latter for hanging dumps.&lt;br/&gt;&lt;br/&gt;Both commands bring a list of information that help us to track the problem. The details description of the command output is discussed in following list:&lt;br/&gt;&lt;br/&gt;FAULTING_IP: shows the value of the instructions pointer when the fault occurred:&lt;br/&gt;FAULTING_IP: &lt;br/&gt;kernel32!RaiseException+53&lt;br/&gt;7c812afb 5e              pop     esi&lt;br/&gt;&lt;br/&gt;EXCEPTION_RECORD: gives more detail about the exception that occurred in the form of an exception record:&lt;br/&gt;EXCEPTION_RECORD:  1e77e998 -- (.exr 0x1e77e998)&lt;br/&gt;.exr 0x1e77e998&lt;br/&gt;ExceptionAddress: 7c812afb (kernel32!RaiseException+0x00000053)&lt;br/&gt;   ExceptionCode: e0434352 (CLR exception)&lt;br/&gt;  ExceptionFlags: 00000001&lt;br/&gt;NumberParameters: 5&lt;br/&gt;   Parameter[0]: 80131500&lt;br/&gt;   Parameter[1]: 00000000&lt;br/&gt;   Parameter[2]: 00000000&lt;br/&gt;   Parameter[3]: 00000000&lt;br/&gt;   Parameter[4]: 79140000&lt;br/&gt;ExceptionAddress shows the address where the exception occurred; ExceptionCode tells us the exact exception that caused the fault; ExceptionFlag show the flag associated with the exception; NumberParameters tells us the number of parameters associated with exception.&lt;br/&gt;&lt;br/&gt;FAULTING_THREAD: tells us which thread caused the fault to occur:&lt;br/&gt;FAULTING_THREAD:  ffffffff&lt;br/&gt;In this specific case, the thread id was not saved, but it is possible to determine which thread caused the fault using other command that will be discussed in later posts.&lt;br/&gt;&lt;br/&gt;BUGCHECK_STR: represents a textual description of the &#x2018;bugcheck&#x2019; that occurred:&lt;br/&gt;BUGCHECK_STR:  APPLICATION_FAULT_CLR_EXCEPTION_WRONG_SYMBOLS&lt;br/&gt;&lt;br/&gt;PROCESS_NAME: tells us the name of the process that exhibiting the fault:&lt;br/&gt;PROCESS_NAME:  devenv.exe&lt;br/&gt;&lt;br/&gt;ERROR_CODE: tells us the error code (NTSTATUS) that caused the fault:&lt;br/&gt;ERROR_CODE: (NTSTATUS) 0xe0434f4d - &amp;lt;Unable to get error code text&gt;&lt;br/&gt;Unfortunately, there is no text information, but in most of cases, there is the information. In lost of cases the text information is not provided, it is possible to identify it by analyzing the content of the id. In this specific case it is possible to infer the code is an E0 &#x2018;COM&#x2019; (43 = &#x2018;C&#x2019;, 4f = &#x2018;O&#x201D;, 4d = &#x2018;M&#x2019;).&lt;br/&gt;Other details can be obtained from Windows EXCEPTION_RECODE structure in &lt;a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa363082%2528v%253Dvs.85%2529.aspx"&gt;MSDN&lt;/a&gt;.&lt;br/&gt;&lt;br/&gt;DEFAULT_BUCKED_ID: details the general category of fault that this particular fault falls under:&lt;br/&gt;DEFAULT_BUCKET_ID:  CLR_EXCEPTION&lt;br/&gt;&lt;br/&gt;PRIMARY_PROBLEM_CLASS: indicates the primary class of the problems that the fault was categorized in:&lt;br/&gt;PRIMARY_PROBLEM_CLASS:  CLR_EXCEPTION&lt;br/&gt;&lt;br/&gt;LAST_CONTROL_TRANSFER: shows the last two functions calls made on the stack:&lt;br/&gt;LAST_CONTROL_TRANSFER:  from 7928bd60 to 7c812afb&lt;br/&gt;The ln &amp;lt;address&gt; command shows the name of the function associated with the address. In this sample, the control was transferred from kernel32!RaiseException to clr!RaiseTheExceptionInternalOnly. This information can also be taken from the stack trace.&lt;br/&gt;&lt;br/&gt;STACK_TEXT: shows the stack trace of the thread:&lt;br/&gt;STACK_TEXT:  &lt;br/&gt;7c812afb kernel32!RaiseException+0x53&lt;br/&gt;7928bd60 clr!RaiseTheExceptionInternalOnly+0x276&lt;br/&gt;7928bf99 clr!IL_Throw+0x14c&lt;br/&gt;0f840c32 Microsoft_Build_ni+0x380c32&lt;br/&gt;0f5b88eb Microsoft_Build_ni+0xf88eb&lt;br/&gt;0f5b8718 Microsoft_Build_ni+0xf8718&lt;br/&gt;79b2ae5b mscorlib_ni+0x2aae5b&lt;br/&gt;79ab7ff4 mscorlib_ni+0x237ff4&lt;br/&gt;79ab7f34 mscorlib_ni+0x237f34&lt;br/&gt;79b2ade8 mscorlib_ni+0x2aade8&lt;br/&gt;791421bb clr!CallDescrWorker+0x33&lt;br/&gt;79164be2 clr!CallDescrWorkerWithHandler+0x8e&lt;br/&gt;79164d84 clr!MethodDesc::CallDescr+0x194&lt;br/&gt;79164db9 clr!MethodDesc::CallTargetWorker+0x21&lt;br/&gt;79294073 clr!ThreadNative::KickOffThread_Worker+0x1e1&lt;br/&gt;792f0d78 clr!Thread::DoExtraWorkForFinalizer+0x114&lt;br/&gt;792f0dfa clr!Thread::ShouldChangeAbortToUnload+0x101&lt;br/&gt;792f0eb5 clr!Thread::ShouldChangeAbortToUnload+0x399&lt;br/&gt;792f0f51 clr!Thread::ShouldChangeAbortToUnload+0x43a&lt;br/&gt;79293f46 clr!ManagedThreadBase::KickOff+0x15&lt;br/&gt;79293e41 clr!ThreadNative::KickOffThread+0x23e&lt;br/&gt;792ec060 clr!Thread::intermediateThreadProc+0x4b&lt;br/&gt;7c80b729 kernel32!BaseThreadStart+0x37&lt;br/&gt;&lt;br/&gt;FOLLOWUP_IP: shows the instruction that most likely caused the fault:&lt;br/&gt;FOLLOWUP_IP: &lt;br/&gt;clr!RaiseTheExceptionInternalOnly+276&lt;br/&gt;7928bd60 c745fcfeffffff  mov     dword ptr [ebp-4],0FFFFFFFEh&lt;br/&gt;&lt;br/&gt;One very important note regarding this and the STACK_TEXT fields is: DO NOT ALWAYS BELIEVE ON THEM! The dump my show them as the caused of the fault, but, as discussed in corruption posts, unpredictable behavior may have led to this point, when the real root of the fault is far away behind! This shall be discussed in other posts.&lt;br/&gt;&lt;br/&gt;SYMBOL_STACK_INDEX: corresponds to the frame in the thread&#x2019;s stack trace that caused the fault:&lt;br/&gt;SYMBOL_STACK_INDEX:  1&lt;br/&gt;&lt;br/&gt;FOLLOWUP_NAME and FOLLOWUP: show who should be following up with this particular fault:&lt;br/&gt;FOLLOWUP_NAME:  MachineOwner&lt;br/&gt;By default, MachineOwner is used but this can be changed modifying the triage.ini file, located at the triage folder in the debugger installation path. You can either ignore a module, or part of it, or associated one module, or part of it, to a specified triage group or person. See the samples below:&lt;br/&gt;nt!Zw*=ignore&lt;br/&gt;This means the any fault on Zw* function of NT module will be ignored.&lt;br/&gt;AppSample!*=Support Team (SupportTeam@AppSampleCompany.com)&lt;br/&gt;This means that any fault on AppSample module the FOLLOWUP_NAME field will be filled with Support Team information.&lt;br/&gt;&lt;br/&gt;MODULE_NAME: states the module that is exhibiting the fault:&lt;br/&gt;MODULE_NAME: clr&lt;br/&gt;&lt;br/&gt;IMAGE_NAME: states the name of the image that fault occurred:&lt;br/&gt;IMAGE_NAME:  clr.dll&lt;br/&gt;&lt;br/&gt;DEBUG_FLR_IMAGE_TIMESTAMP: shows the image time stamp where the fault occurred:&lt;br/&gt;DEBUG_FLR_IMAGE_TIMESTAMP:  4e181a6d&lt;br/&gt;&lt;br/&gt;SYMBOL_NAME: shows the symbolic name where the fault occurred:&lt;br/&gt;SYMBOL_NAME:  clr!RaiseTheExceptionInternalOnly+276&lt;br/&gt;&lt;br/&gt;STACK_COMMAND: shows the command that were executed to get the stack trace for the faulting thread:&lt;br/&gt;STACK_COMMAND:  .cxr 1E77E9C0 ; kb ; dds 1e77ec8c ; kb&lt;br/&gt;This field helps to understand the steps performed by the !analyze extension command. More details about the command performed above and others will be discussed in laters posts.&lt;br/&gt;&lt;br/&gt;FAILURE_BUCKET_ID and BUCKET_ID: show the specific category of the problems that the fault falls under:&lt;br/&gt;FAILURE_BUCKET_ID:  CLR_EXCEPTION_e0434f4d_clr.dll!RaiseTheExceptionInternalOnly&lt;br/&gt;BUCKET_ID:  APPLICATION_FAULT_CLR_EXCEPTION_WRONG_SYMBOLS_clr!RaiseTheExceptionInternalOnly+276&lt;br/&gt;This information can be used by the !analyze extension command to determine what additional information to display in the analysis result.&lt;br/&gt;&lt;br/&gt;CONTEXT: shows the fault context address and registers at the moment of the fault occurred:&lt;br/&gt;CONTEXT:  1e77e9c0 -- (.cxr 0x1e77e9c0)&lt;br/&gt;.cxr 0x1e77e9c0&lt;br/&gt;eax=1e77ec90 ebx=00000005 ecx=00000000 edx=0000004b esi=1e77ed50 edi=161a9158&lt;br/&gt;eip=7c812afb esp=1e77ec8c ebp=1e77ece0 iopl=0         nv up ei pl nz na pe nc&lt;br/&gt;cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206&lt;br/&gt;kernel32!RaiseException+0x53:&lt;br/&gt;7c812afb 5e              pop     esi&lt;br/&gt;.cxr&lt;br/&gt;Resetting default scope&lt;br/&gt;The 1e77e9c0 address is the context of the fault. This field also shows the same information provided by the FAULTING_IP field.&lt;br/&gt;&lt;br/&gt;The order the data is exhibited depends on the type of the fault. Furthermore, there may be other details depending on the fault. For instance, in case of a hang (!analyze -v -hang), one may see the following details:&lt;br/&gt;&lt;br/&gt;CRITICAL_SECTION: shows the address of the critical section tha was found and analyzed in the starting thread.&lt;br/&gt;&lt;br/&gt;BLOCKING_THREAD: gives the ID of the thread that is blocking on the critical section shown in CRITICAL_SECTION field.&lt;br/&gt;&lt;br/&gt;DERIVED_WAIT_THREAD: is at the heart of the hang analysis capabilities of the !analyze extension command. When the command runs, it attempts to derive how the wait chain looks for each of the threads in the process associated with the critical section listed in the CRITICAL_SECTION field. It tries to retrieve which thread is waiting for the critical section and which thread owns it.&lt;br/&gt;&lt;br/&gt;WAIT_CHAIN_COMMAND: shows the commands that can be used to further analyze the wait chain of the problematic lock.&lt;br/&gt;&lt;br/&gt;Additionally, if the application is instrumented, for instance using the Application Verifier and/or gflags, more fields can be seen in the !analyze extension command result:&lt;br/&gt;&lt;br/&gt;NTGLOBALFLAG: shows the flags enabled by the gflags:&lt;br/&gt;NTGLOBALFLAG:  0&lt;br/&gt;In this case, there were not flags enabled for the fault module.&lt;br/&gt;&lt;br/&gt;APPLICATION_VERIFIER_FLAGS: shows the flags enabled using the Application Verifier:&lt;br/&gt;APPLICATION_VERIFIER_FLAGS:  0&lt;br/&gt;&lt;br/&gt;All samples above came from a real crash in the Visual Studio 2010, while I was running my application under debug mode. The application was flagged by both gflags and Application Verifier, but I had not set them for the VS. That means the system had those tools installed. If, on the other hand, the system does not have them, those fields will not appear in the !analyze extension command result.</description>
      <iweb:comment enabled="0" count="0" link="file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog/Entries/2013/2/8_WinDbg_Part_I.html#comment_layer"></iweb:comment>
    </item>
    <iweb:dateFormat>d 'de' MMMM 'de' y</iweb:dateFormat>
    <iweb:baseURL>file://localhost/Users/Giuli/Sites/DeGiuli.com/DeGiuli/Blog</iweb:baseURL>
    <iweb:maximumSummaryItems>5</iweb:maximumSummaryItems>
  </channel>
</rss>
